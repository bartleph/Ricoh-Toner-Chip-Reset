
/* This code updates Ricoh Toner chip for Ricoh Aficio SP C240SF, SP C240DN, C240e, etc...

 V1.0 Original by DIY Tinker 26th Feb 2018
 V2.0 Modified by Paul Bartlett 09th Feb 2020 ...To manually specify which toner variety to reset.
 V3.0 Modified by Paul Bartlett 03rd Jan 2025 ...To Automatically detect which toner variety to reset.
 
   ______________________
   \                    /
   / ___  ___  ___  ___ \
   || S || S || V || G ||
   || C || D || C || N ||
   || L || A || C || D ||
   ||___||___||___||___||
   \____________________/ 

     A5   A4   +5v  Gnd
*/
#include <Arduino.h>
int EEPROM_I2C_ADDRESS;
#include <Wire.h>

// blank data for K, C, M & Y chip. 128 array of data. I got it from data dump of a replacement chip. 
byte KChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x34, 0x32, 0x32, 0x09, 0x03, 0x41, 0x42, 0x01, 0x04, 0x34, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte CChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31, 
  0x35, 0x32, 0x38, 0x31, 0x09, 0x02, 0x41, 0x42, 0x11, 0x00, 0x0F, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte MChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x32, 0x38, 0x33, 0x09, 0x02, 0x41, 0x42, 0x33, 0x00, 0x1E, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte YChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x32, 0x38, 0x32, 0x09, 0x02, 0x41, 0x42, 0x30, 0x00, 0x27, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
int inputByte;

byte getaddress() {
  byte error, address;
  int nDevices = 0;
  Serial.println("*******************************************************************************");
  Serial.println("** Ricoh Aficio SP C240SF, SP C240DN, C240e, etc... Toner Chip Reset Utility **");
  Serial.println("**                 V2.0 Paul Bartlett 03rd January 2025                      **");
  Serial.println("*******************************************************************************");
  Serial.println();
  Serial.println("Scanning...");

  for (address = 80; address < 84; address++) { //I2C addresses for the toner chips are decimal 80, 81, 82, 83
                                                //0x50, 0x51, 0x52, 0x53
    Serial.print("Checking address 0x");
    Serial.println(address, HEX);
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    
    if (error == 0) {
      Serial.print("I2C device found at address 0x");
      if (address < 16)
        Serial.print("0");
      Serial.println(address, HEX);
      return address; // Return the first device address found
    }
  }

  if (nDevices == 0) {
    Serial.println("No I2C devices found.");
  }
  return 0xFF; // Return 0xFF if no devices are found
}

void stop()
{
  while(1);
}

void setup() {
   // Start Wire and Serial bus
  Serial.begin(115200);
  Serial.print("\033[0H\033[0J"); //Clear terminal Screen.
  Wire.begin();
  EEPROM_I2C_ADDRESS=getaddress(); //determine I2C address of toner chip
    switch(EEPROM_I2C_ADDRESS) {
    case 0x50 :
      Serial.println(" Yellow  Toner Reset");
      break;
    case 0x51 :
      Serial.println(" Magenta Toner Reset");
      break;
    case 0x52 :
      Serial.println(" Cyan    Toner Reset");
      break;
    case 0x53 :
      Serial.println(" Black   Toner Reset");
      break;
    case 0xFF :
      Serial.println("No Toner Chip Present.");
      stop();
  }
  delay(5000);
  // Select correct data for chip then copy to WriteData array
  byte WriteData[128];
  delay(100);
  Serial.println("Start");
  Serial.println(" ");
  // Start Write Chip with blank data
  Serial.println("Write 128 bytes:");
  byte wordaddress;
  for(byte i=0;i<128;i++){
        wordaddress = i;
        i2cwrite((byte)wordaddress,(byte)WriteData[i]);
        Serial.print(wordaddress);
        Serial.print(":");
        Serial.print(WriteData[i]);
        Serial.println(" ");
  }
  // Start Read chip
  Serial.println(" ");
  Serial.println("Read 128 bytes:");
  for(byte i=0;i<128;i++){
      byte readVale = i2cread(i);
      Serial.print(i);
      Serial.print(":");
      Serial.print(readVale);
      Serial.println(" ");
  } 
  Serial.println(" ");  
  Serial.println("End");
}

void loop() {
}

void i2cwrite(byte address, byte data) {
  Wire.beginTransmission(EEPROM_I2C_ADDRESS);
  Wire.write((byte)address);
  Wire.write((byte)data);
  Wire.endTransmission();
  delay(20);
}

byte i2cread(byte address) {
  byte rData = 0;
  // Begin I2C transmission
  Wire.beginTransmission(EEPROM_I2C_ADDRESS);
  Wire.write(address); // Send the memory address to read
  Wire.endTransmission();
  // Request 1 byte from the EEPROM
  Wire.requestFrom(EEPROM_I2C_ADDRESS, 1);
  // Read the data
  if (Wire.available()) {
    rData = Wire.read();
  }
  return rData; // Return the read byte, even if it's 0 (default)
}
