/* This code updates Ricoh Toner chip for Ricoh Aficio SP C240SF, SP C240DN, C240e, etc...

 Original by DIY Tinker 26th Feb 2018
 Modified by Paul Bartlett 09th Feb 2020
 
   ______________________
   \                    /
   / ___  ___  ___  ___ \
   || S || S || V || G ||
   || C || D || C || N ||
   || L || A || C || D ||
   ||___||___||___||___||
   \____________________/ 

     A5   A4   +5v  Gnd
*/

int EEPROM_I2C_ADDRESS;
#include <Wire.h>

// blank data for K, C, M & Y chip. 128 array of data. I got it from data dump of a replacement chip. 
byte KChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x34, 0x32, 0x32, 0x09, 0x03, 0x41, 0x42, 0x01, 0x04, 0x34, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte CChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31, 
  0x35, 0x32, 0x38, 0x31, 0x09, 0x02, 0x41, 0x42, 0x11, 0x00, 0x0F, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte MChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x32, 0x38, 0x33, 0x09, 0x02, 0x41, 0x42, 0x33, 0x00, 0x1E, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte YChipData[]={0xA7, 0x00, 0x01, 0x01, 0x14, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x35, 0x31,
  0x35, 0x32, 0x38, 0x32, 0x09, 0x02, 0x41, 0x42, 0x30, 0x00, 0x27, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
char inputByte="";
byte getaddress() {
  byte error, address;
  int nDevices;

  Serial.println("Scanning...");

  nDevices = 0;
  for (address = 1; address < 127; address++ ) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();

    if (error == 0) {
      Serial.print("I2C device found at address 0x");
      if (address < 16)
        Serial.print("0");
      Serial.print(address, HEX);
      Serial.println("  !");

      nDevices++;
    }
    else if (error == 4) {
      Serial.print("Unknown error at address 0x");
      if (address < 16)
        Serial.print("0");
      Serial.println(address, HEX);
      return address;
    }
  }
  if (nDevices == 0)
    Serial.println("No I2C devices found\n");
  else
    Serial.println("done\n");

  delay(5000);
}
void setup() {
  Serial.begin(115200);
  Serial.println("Toner chip reset utility. ver 2.1 (c)PHB 2020");
  Serial.println("Enter capital Letter for Cartridge Chip to zero? (B)lack (M)agenta (C)yan (Y)ellow?");
  while(!Serial.available()){
    ;
  }
  inputByte=Serial.read();
  
  // Select correct data for chip then copy to WriteData array
  byte WriteData[128];
  switch (inputByte){
    case 'B':
      memcpy(WriteData,KChipData,128*sizeof(byte));
      EEPROM_I2C_ADDRESS=83;
      break;
    case 'C':
      memcpy(WriteData,CChipData,128*sizeof(byte));
      EEPROM_I2C_ADDRESS=82;
      break; 
    case 'M':
      memcpy(WriteData,MChipData,128*sizeof(byte));
      EEPROM_I2C_ADDRESS=81;
      break;
    case 'Y':
      memcpy(WriteData,YChipData,128*sizeof(byte));
      EEPROM_I2C_ADDRESS=80;
      break;
    default: //default K chip data, no reason.
      Serial.println("Incorrect....Reboot Arduino and try again!");
      delay(1000);
      return;
  }
  
  // Start Wire and Serial bus
  Wire.begin();
  
  delay(100);

  Serial.println("Start");
  Serial.println(" ");

  // Start Write Chip with blank data
  Serial.println("Write 128 bytes:");
  byte wordaddress;

  for(byte i=0;i<128;i++){
        wordaddress = i;
        i2cwrite((byte)wordaddress,(byte)WriteData[i]);
        Serial.print(wordaddress);
        Serial.print(":");
        Serial.print(WriteData[i]);
        Serial.println(" ");
  }

  // Start Read chip
  Serial.println(" ");
  Serial.println("Read 128 bytes:");
  for(byte i=0;i<128;i++){
      byte readVale = i2cread(i);
      Serial.print(i);
      Serial.print(":");
      Serial.print(readVale);
      Serial.println(" ");
  } 
  Serial.println(" ");  
  Serial.println("End");

}

void loop() {

}

void i2cwrite(byte address, byte data) {
  Wire.beginTransmission(EEPROM_I2C_ADDRESS);
  Wire.write((byte)address);
  Wire.write((byte)data);
  Wire.endTransmission();
  delay(20);
}

byte i2cread(byte address) {
  byte rData = 0;
  Wire.beginTransmission(EEPROM_I2C_ADDRESS);
  Wire.write((byte)address);
  Wire.endTransmission();

  Wire.requestFrom(EEPROM_I2C_ADDRESS,1);
  while (Wire.available()){
    rData = Wire.read();
    return rData;
  }
}

void WhatI2CAddress() {
    for(int i=0;i<128;i++){
      Wire.requestFrom(i,1);  //request first data byte
      Serial.print(i);
      Serial.print(":");
      while(Wire.available()){
        byte c = Wire.read();
        Serial.println(c);      //if data exist, print it out. That way you can identify which address.
      }
      Serial.println(" ");
      delay(5);
  }
}
